import FluidModel from "./model";
import type * as fType from "./types";

/**
 * Base class for generating random audio samples with a range of plugin parameters.
 */
export abstract class Generator {
  samples: fType.noteArray[] = [];
  model: FluidModel;
  sampleNum: number = 0;
  completed: number = 0;
  batchNum: number = 0;
  clientOptions: fType.clientOptions = {
    targetPort: 9999,
    targetHost: '127.0.0.1',
    header: 0xf2b49e2c,
    timeout: 30000000,
    isUnixDomainSocket: false,
  }

  /**
   * @param {fType.paramArray} params An array of objects that look like:
   *       { param: string, min: number, max: number, numQueries: number}
   * @param {number} batches The number of batches we should generate
   * @param {fType.clientOptions} options Options object for a FluidIpcClient.
   */
  constructor (
    readonly params: fType.paramArray,
    readonly batches: number,
    readonly options? : fType.clientOptions,
  ) {
    this.model = new FluidModel();
    if (options) this.clientOptions = options;
  }

  /**
   * Abstract function that is called by `recurHelper` 
   * 
   * The function should implement sending a bundle to the Fluid Engine
   * that renders an audio file using the specified values in `v`.
   * 
   * @param {Object} v values, an object with a key for each parameter and a value
   *                   that the parameter should be set to.
   *                   e.g. { delay: 200, feedback: 30 }
   * @param {fType.noteArray} sample a sample generated by getSamples()
   */
  async abstract send(v: any, sample: fType.noteArray): Promise<void>;

  /**
   * Generates `batches * (param.numQueries for each parameter)` random 4 bar melodies using the 
   * magenta.js library, and converts them into noteArrays that can be read by the Fluid Engine
   */
  async getSamples(): Promise<fType.noteArray[]> {
    let numOfSamples = this.batches;
    for (let param of Object.values(this.params)){
      numOfSamples *= param.numQueries;
    }
  
    console.log('Generating', numOfSamples, 'samples');
  
    await this.model.load();
    const outputMel = await this.model.sampleMel(numOfSamples);
    console.log('Samples Generated')
  
    const samples = [];
    for (let sample of outputMel) {
      const notes = this.model.melNotesToFluid(sample.notes, sample.quantizationInfo!.stepsPerQuarter!)
      samples.push(notes);
    }
    
    this.sampleNum = 0;
    return samples;
  }

  /** 
   * `generate` calls `send` with every combination of values parameters can be set to,
   * `batches` times
   */
  async generate() {
    this.samples = await this.getSamples();
    this.completed = 0;
    this.batchNum = 0;

    const getInterval = (min: number, max: number, num: number) => {
      if ( num === 1 ) return 0;
      return (max - min) / (num - 1)
    };

    // Recursive helper function for the generate function
    // to support changing an arbitiary number of parameters.
    const recurHelper  = async (curr: number, values: any): Promise<void> => {
      if (curr === Object.entries(this.params).length){
        await this.send(values, this.samples[this.sampleNum]);
        this.sampleNum++;
      } else{
        for (let i = this.params[curr].min; i <= this.params[curr].max; 
          i += getInterval(this.params[curr].min, this.params[curr].max , this.params[curr].numQueries)){
    
          values[this.params[curr].param] = i;
          await recurHelper(curr + 1, values);
        }
      }
    }

    for (let iter = 0; iter < this.batches; iter++){
      console.log('Sending batch:', iter);
      await recurHelper(0, {});
    }
  
    console.log('done')
  }
}